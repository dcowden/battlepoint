#include <Arduino.h>
#include <Wire.h>
#include <math.h>
#include <string>

#include "esp_sleep.h"   // <-- added for light sleep

#define COLOR_RED     255,0,0
#define COLOR_BLUE    0,0,255
#define COLOR_YELLOW  255,255,0
#define COLOR_PURPLE  128,0,128
#define COLOR_GREEN   0,180,0
#define COLOR_GRAY    100,100,100

// ------------------ NeoPixel -------------
#include <Adafruit_NeoPixel.h>

// ------------------ QMC auto-detect ------
#include "qmc5883.h"

#include "ble.h"
#include "led.h"   // our LED wrapper

// ------------------ Debounce -------------
#include <Bounce2.h>

// ============================================================================
// --------------------- USER / HW CONFIG -------------------------------------
// ============================================================================

// We keep this flag and the color constants around for future use,
// but we no longer use field direction for team detection.
static const bool POSITIVE_Z_IS_BLUE = true;
static const int SDA_PIN = 8;
static const int SCL_PIN = 9;

static const char ADV_PRESENCE_VALUE_RED   = 'R';
static const char ADV_PRESENCE_VALUE_BLU   = 'B';
static const char ADV_PRESENCE_VALUE_BOTH  = 'T';
static const char ADV_PRESENCE_VALUE_NONE  = 'N';
// NEW: magnet-only presence, team indeterminate
static const char ADV_PRESENCE_VALUE_MAG   = 'M';

// NOTE: on XIAO ESP32-C3 SDA/SCL are 4/5.
// If you actually use I2C on 4/5, move the LED to another pin.
#define LED_PIN        3
#define NUM_LEDS       1

// switch inputs (normally open to GND)
static const int BLUE_SWITCH_PIN = 1;  // closed => blue present
static const int RED_SWITCH_PIN  = 2;  // closed => red present

// LED wrapper instance
StatusLED statusLed(LED_PIN, NUM_LEDS);

// debouncers for the switches
Bounce blueSwitchDebouncer;
Bounce redSwitchDebouncer;

// ============================================================================
// ------------------ QMC5883 baseline / EMA params ---------------------------

const float BASELINE_ALPHA   = 0.05f;
const float OUTPUT_ALPHA     = 0.50f;
const unsigned long BASELINE_MS = 10000UL;

float baseX = 0, baseY = 0, baseZ = 0;
bool  baselineInit  = false;
bool  baselineDone  = false;
unsigned long tStart = 0;

bool  outputEmaInit = false;
float fDx = 0, fDy = 0, fDz = 0, fDt = 0;

// presence thresholds (field magnitude vs baseline)
const float MIN_ON_DT   = 380.0f;
const float OFF_HYST_DT = 360.0f;

BleReporter reporter;

// magnetic presence only (no team inference from field)
bool  g_playerPresent = false;
float g_lastDt        = 0.0f;

// flag telling us if the QMC is present & initialized
bool g_qmc_present = false;

// ============================================================================
// ------------------- Arduino setup / loop -----------------------------------
void setup() {
  Serial.begin(115200);

  //setCpuFrequencyMhz(80);

  delay(200);
  Serial.println("Startup...");
  //WiFi.mode(WIFI_OFF);
  //WiFi.disconnect(true, true);
  statusLed.begin(64);
  statusLed.off();

  // I2C init
  Wire.begin(SDA_PIN, SCL_PIN);
  Wire.setTimeout(50);

  // switch pins with pullups
  pinMode(BLUE_SWITCH_PIN, INPUT_PULLUP);
  pinMode(RED_SWITCH_PIN,  INPUT_PULLUP);

  blueSwitchDebouncer.attach(BLUE_SWITCH_PIN);
  blueSwitchDebouncer.interval(20);  // 20 ms debounce

  redSwitchDebouncer.attach(RED_SWITCH_PIN);
  redSwitchDebouncer.interval(20);   // 20 ms debounce

  // capture whether the QMC is actually present
  g_qmc_present = initQMC5883P();   // auto-detect/init_qmc() from qmc5883.h

  if (!g_qmc_present) {
    Serial.println("QMC not detected; running in switch-only mode.");
    baselineDone = true;  // skip baseline if no sensor
  }

  tStart = millis();

  reporter.begin();
}

void loop() {
  // ----------------- Update debounced switch state -----------------
  blueSwitchDebouncer.update();
  redSwitchDebouncer.update();

  // Active LOW because of INPUT_PULLUP and normally-open to GND
  bool blueSwitchOn = (blueSwitchDebouncer.read() == LOW);
  bool redSwitchOn  = (redSwitchDebouncer.read() == LOW);

  // ----------------- Magnetic sensor path (presence only) -----------
  if (g_qmc_present) {
    int16_t rx, ry, rz;
    if (!readQMC5883PData(rx, ry, rz)) {
      // If QMC was present at boot but a read fails, bail out of this iteration
      // to avoid using bogus data.
      statusLed.update();
      delay(10);
      return;
    }

    float x = rx;
    float y = ry;
    float z = rz;

    unsigned long now = millis();

    // ----------------- Baseline phase -----------------
    if (!baselineDone) {
      if (!baselineInit) {
        baseX = x; baseY = y; baseZ = z;
        baselineInit = true;
      } else {
        baseX = BASELINE_ALPHA * x + (1 - BASELINE_ALPHA) * baseX;
        baseY = BASELINE_ALPHA * y + (1 - BASELINE_ALPHA) * baseY;
        baseZ = BASELINE_ALPHA * z + (1 - BASELINE_ALPHA) * baseZ;
      }

      Serial.println(F(">baseline_building:1"));

      statusLed.setFastBlink(COLOR_YELLOW);
      statusLed.update();

      if (now - tStart >= BASELINE_MS) {
        baselineDone = true;
        Serial.println(F("=== Baseline established ==="));
        Serial.print(F("base_x: ")); Serial.println(baseX, 2);
        Serial.print(F("base_y: ")); Serial.println(baseY, 2);
        Serial.print(F("base_z: ")); Serial.println(baseZ, 2);
        Serial.println(F("==========================="));
      }

      delay(10);
      return;
    }

    // ----------------- Run phase -----------------
    float dx = x - baseX;
    float dy = y - baseY;
    float dz = z - baseZ;
    float dt = magnitude3D(dx, dy, dz);

    if (!outputEmaInit) {
      fDx = dx;
      fDy = dy;
      fDz = dz;
      fDt = dt;
      outputEmaInit = true;
    } else {
      fDx = OUTPUT_ALPHA * dx + (1 - OUTPUT_ALPHA) * fDx;
      fDy = OUTPUT_ALPHA * dy + (1 - OUTPUT_ALPHA) * fDy;
      fDz = OUTPUT_ALPHA * dz + (1 - OUTPUT_ALPHA) * fDz;
      fDt = OUTPUT_ALPHA * dt + (1 - OUTPUT_ALPHA) * fDt;
    }
    Serial.printf(">fDt: %0.1f\n", fDt);
    Serial.printf(">fDx: %0.1f\n", fDx);
    Serial.printf(">fDy: %0.1f\n", fDy);
    Serial.printf(">fDz: %0.1f\n", fDz);
    g_lastDt = fDt;

    // presence FSM (magnet-based only)
    if (!g_playerPresent) {
      if (fDt >= MIN_ON_DT) {
        g_playerPresent = true;
      }
    } else {
      if (fDt <= OFF_HYST_DT) {
        g_playerPresent = false;
      }
    }

  } else {
    // No QMC: ensure magnetic presence does not contribute
    g_playerPresent = false;
  }

  // ----------------- Combine magnetic + switch presence -----------------
  bool magPresent  = g_playerPresent;   // man-on from magnet only
  bool bluePresent = false;
  bool redPresent  = false;

  // From switches (definitive team)
  if (blueSwitchOn) bluePresent = true;
  if (redSwitchOn)  redPresent  = true;

  bool anyPlayerPresent = (magPresent || bluePresent || redPresent);

  char teamCharAdv = ADV_PRESENCE_VALUE_NONE;

  if (bluePresent && redPresent) {
    // both switches: keep previous behavior
    teamCharAdv = ADV_PRESENCE_VALUE_BOTH;
  } else if (bluePresent) {
    teamCharAdv = ADV_PRESENCE_VALUE_BLU;
  } else if (redPresent) {
    teamCharAdv = ADV_PRESENCE_VALUE_RED;
  } else if (magPresent) {
    // magnet-only presence: team unknown
    teamCharAdv = ADV_PRESENCE_VALUE_MAG;
  } else {
    teamCharAdv = ADV_PRESENCE_VALUE_NONE;
  }

  // ----------------- LED state -----------------
  if (!anyPlayerPresent) {
    // Blinking green when ready to capture but nobody on
    statusLed.setFastBlink(COLOR_GREEN);
  } else {
    // If switches say something, trust them for color.
    if (bluePresent && redPresent) {
      statusLed.setSolid(COLOR_PURPLE);  // both
    } else if (bluePresent) {
      statusLed.setSolid(COLOR_BLUE);
    } else if (redPresent) {
      statusLed.setSolid(COLOR_RED);
    } else if (magPresent) {
      // magnet-only presence: solid green
      statusLed.setSolid(COLOR_GREEN);
    } else {
      // Fallback (shouldn't really hit)
      statusLed.setSolid(COLOR_GRAY);
    }
  }

  // Debug for presence breakdown
  if (!anyPlayerPresent) {
    Serial.println(">P: 0");  // nobody
  } else if (bluePresent && !redPresent && !magPresent) {
    Serial.println(">P: 1");  // blue only (switch)
  } else if (redPresent && !bluePresent && !magPresent) {
    Serial.println(">P: 2");  // red only (switch)
  } else if (bluePresent && redPresent) {
    Serial.println(">P: 3");  // both switches
  } else if (magPresent && !bluePresent && !redPresent) {
    Serial.println(">P: 4");  // magnet only
  } else {
    Serial.println(">P: 5");  // mixed case (switch + magnet)
  }

  // BLE FSM (includes combined teamCharAdv)
  // If QMC is absent, fDt stays at its default (0.0f), which is fine.
  reporter.update(anyPlayerPresent, fDt, teamCharAdv);

  // Update LED blink timing
  statusLed.update();

  // ----------------- Power management -----------------
  if (!anyPlayerPresent) {
    // No player: light sleep for ~50 ms to save power
    const uint64_t sleep_us = 50ULL * 1000ULL;  // 50 ms in microseconds
    esp_sleep_enable_timer_wakeup(sleep_us);
    esp_light_sleep_start();
    // Wakeup will return here and the loop will run again.
  } else {
    // Player present: keep responsiveness high
    delay(10); // ~100 Hz
  }
}
