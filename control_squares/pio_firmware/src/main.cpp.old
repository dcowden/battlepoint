#include <Arduino.h>
#include <Wire.h>
#include <math.h>

// ------------------ BLE ------------------
#include <NimBLEDevice.h>

// ------------------ NeoPixel -------------
#include <Adafruit_NeoPixel.h>

// ============================================================================
// --------------------- USER / HW CONFIG -------------------------------------
// ============================================================================

// LED
// XIAO ESP32-C3 uses GPIO4 / GPIO5 for default I2C. Put the NeoPixel somewhere else.
#define LED_PIN        10
#define NUM_LEDS       1

// Adafruit NeoPixel strip: 1 pixel, GRB, 800 kHz
Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// Tile identity
static const char* TILE_ID = "SQ-01";  // change per tile

// Shared service UUID that **all** your tags and tiles should use
static const char* SHARED_SERVICE_UUID_STR = "12345678-1234-1234-1234-1234567890ab";

// Manufacturer ID (little-endian in adv)
static const uint16_t MFG_COMPANY_ID = 0xFFFF;

// BLE scan window for presence -> player lookup
static const uint16_t SCAN_TIME_MS = 800;

// TX power for this tile’s advertising
static const esp_power_level_t TILE_TX_POWER = ESP_PWR_LVL_P6; // or P9

// ============================================================================
// ------------------ QMC5883P -------------------------------------------------
// ============================================================================
const int QMC5883P_ADDR = 0x2C;

// EMA for baseline build
const float BASELINE_ALPHA = 0.05f;
// EMA for plotted output (Dx, Dy, Dz, Dt)
const float OUTPUT_ALPHA   = 0.10f;

// how long to build baseline (15 s)
const unsigned long BASELINE_MS = 15000UL;

// registers
const int MODE_REG   = 0x0A;
const int CONFIG_REG = 0x0B;
const int X_LSB_REG  = 0x01;

// baseline state
float baseX = 0, baseY = 0, baseZ = 0;
bool baselineInit  = false;
bool baselineDone  = false;
unsigned long tStart = 0;

// output EMA state (for Dx/Dy/Dz/Dt)
bool outputEmaInit = false;
float fDx = 0, fDy = 0, fDz = 0, fDt = 0;

// ------------------- presence thresholds (relative) --------------------
const float MIN_ON_DT     = 400.0f;   // enter ON above this
const float STRONG_DT     = 1100.0f;  // GREEN above this
const float OFF_HYST_DT   = 300.0f;   // leave below this

// ============================================================================
// ------------------- LED wrapper (Adafruit_NeoPixel) ------------------------
// ============================================================================
class StatusLED {
public:
  StatusLED(uint16_t count)
  : _count(count), _r(0), _g(0), _b(0), _haveColor(false) {}

  void begin(uint8_t brightness = 64) {
    strip.begin();
    strip.setBrightness(brightness);
    off();
  }

  void set(uint8_t r, uint8_t g, uint8_t b) {
    if (!_haveColor || r != _r || g != _g || b != _b) {
      _r = r; _g = g; _b = b;
      _haveColor = true;
      strip.setPixelColor(0, strip.Color(r, g, b));
      strip.show();
      Serial.printf("LED -> %s (%u,%u,%u)\n", colorName(r, g, b), r, g, b);
    }
  }

  // convenience
  void off()    { set(0, 0, 0); }
  void red()    { set(255, 0, 0); }
  void yellow() { set(255, 180, 0); }
  void green()  { set(0, 180, 0); }
  void blue()   { set(0, 0, 255); }

private:
  uint16_t _count;
  uint8_t  _r, _g, _b;
  bool     _haveColor;

  const char* colorName(uint8_t r, uint8_t g, uint8_t b) {
    if (r == 0 && g == 0 && b == 0) return "Black";
    if (r > 220 && g < 60  && b < 60)  return "Red";
    if (g > 160 && r < 80  && b < 80)  return "Green";
    if (b > 160 && r < 80  && g < 80)  return "Blue";
    if (r > 200 && g > 120 && b < 80)  return "Yellow";
    if (r > 200 && b > 200)            return "Magenta";
    if (g > 150 && b > 150)            return "Cyan";
    if (r > 180 && g > 180 && b > 180) return "White";
    return "Custom";
  }
};

StatusLED statusLed(NUM_LEDS);

// ============================================================================
// ------------------- QMC funcs ----------------------------------------------
// ============================================================================
void initQMC5883P() {
  // default SDA/SCL for XIAO ESP32-C3 → 4/5. LED is on 10, so we’re good.
  Wire.begin();
  // continuous, 200 Hz
  Wire.beginTransmission(QMC5883P_ADDR);
  Wire.write(MODE_REG);
  Wire.write(0xCF);
  Wire.endTransmission();

  // set/reset on, ±8G
  Wire.beginTransmission(QMC5883P_ADDR);
  Wire.write(CONFIG_REG);
  Wire.write(0x08);
  Wire.endTransmission();
}

bool readQMC5883PData(int16_t &x, int16_t &y, int16_t &z) {
  Wire.beginTransmission(QMC5883P_ADDR);
  Wire.write(X_LSB_REG);
  if (Wire.endTransmission(false) != 0) return false;

  Wire.requestFrom(QMC5883P_ADDR, 6);
  if (Wire.available() != 6) return false;

  byte x_lsb = Wire.read();
  byte x_msb = Wire.read();
  byte y_lsb = Wire.read();
  byte y_msb = Wire.read();
  byte z_lsb = Wire.read();
  byte z_msb = Wire.read();

  x = (x_msb << 8) | x_lsb;
  y = (y_msb << 8) | y_lsb;
  z = (z_msb << 8) | z_lsb;
  return true;
}

float magnitude3D(float x, float y, float z) {
  return sqrtf(x * x + y * y + z * z);
}

// ============================================================================
// ------------------- Reporter (BLE)  -- nonblocking scan --------------------
// ============================================================================
class BleReporter {
public:
  enum State {
    IDLE,
    SCANNING,
    ADVERTISING
  };

  BleReporter()
  : _state(IDLE),
    _pScan(nullptr),
    _scanStart(0),
    _bestRssi(-999),
    _haveCurrentTag(false),
    _lastAdvUpdate(0),
    _seq(0),
    _lastPlayerPresent(false)
  {}

  void begin() {
    NimBLEDevice::init(TILE_ID);
    NimBLEDevice::setPower(TILE_TX_POWER);

    _pScan = NimBLEDevice::getScan();
    _pScan->setActiveScan(true);
    _pScan->setInterval(100);
    _pScan->setWindow(100);
    _pScan->setDuplicateFilter(false);
  }

  // call every loop
  void update(bool playerPresent, float strength /* smoothed Dt */) {
    unsigned long now = millis();

    // 1) player left -> tear everything down
    if (!playerPresent) {
      if (_state == SCANNING) {
        _pScan->stop();
        _pScan->clearResults();
      }
      if (_state == ADVERTISING) {
        stopAdvertising();
      }
      _state = IDLE;
      _lastPlayerPresent = false;
      return;
    }

    // 2) player just arrived -> start a timed, nonblocking scan
    if (playerPresent && !_lastPlayerPresent) {
      startScan(now);
      _lastPlayerPresent = true;
      return;
    }

    // 3) player is still there -> run FSM
    switch (_state) {
      case IDLE:
        // defensive: if we got here, restart a scan
        startScan(now);
        break;

      case SCANNING: {
        // let the NimBLE stack fill results in the background
        if (now - _scanStart >= SCAN_TIME_MS) {
          _pScan->stop();

          NimBLEScanResults results = _pScan->getResults();
          pickBestFromResults(results);
          _pScan->clearResults();

          startAdvertising();
          _state = ADVERTISING;
        }
      } break;

      case ADVERTISING: {
        // keep pushing strength into the mfg field
        if (now - _lastAdvUpdate >= 250) {
          _lastAdvUpdate = now;
          _seq++;
          updateAdvPacket(strength);
        }
      } break;
    }
  }

private:
  State _state;
  NimBLEScan* _pScan;
  unsigned long _scanStart;

  int _bestRssi;
  String _bestTagName;
  bool _haveCurrentTag;

  unsigned long _lastAdvUpdate;
  uint8_t _seq;

  bool _lastPlayerPresent;   // to detect rising edge

  void startScan(unsigned long now) {
    Serial.println("BLE: startScan()");
    _bestRssi = -999;
    _bestTagName = "";
    _haveCurrentTag = false;

    // nonblocking continuous scan – we will stop it ourselves
    _pScan->start(0, false);

    _scanStart = now;
    _state = SCANNING;
  }

  void pickBestFromResults(const NimBLEScanResults &results) {
    Serial.println("BLE: selecting best PT-*");
    for (int i = 0; i < results.getCount(); i++) {
      const NimBLEAdvertisedDevice* dev = results.getDevice(i);
      if (!dev) continue;

      int rssi = dev->getRSSI();
      std::string nm = dev->getName();

      // debug
      Serial.printf("%s: %d\n", nm.c_str(), rssi);

      bool nameOk = (!nm.empty() && nm.rfind("PT-", 0) == 0);
      if (!nameOk) continue;

      if (rssi > _bestRssi) {
        _bestRssi = rssi;
        _bestTagName = String(nm.c_str());
        _haveCurrentTag = true;
      }
    }
  }

  void startAdvertising() {
    Serial.printf("BLE: advertising player %s\n",
                  _haveCurrentTag ? _bestTagName.c_str() : "PT-UNK");

    NimBLEAdvertising *adv = NimBLEDevice::getAdvertising();

    NimBLEAdvertisementData advData;
    advData.setFlags(0x06);
    advData.setCompleteServices(NimBLEUUID(SHARED_SERVICE_UUID_STR));

    std::string mfg = buildManufacturerData(
        _haveCurrentTag ? _bestTagName.c_str() : "PT-UNK",
        0  // strength first sample
    );
    advData.setManufacturerData(mfg);
    advData.setName(TILE_ID);

    uint16_t intervalMs = 40;
    uint16_t units = (uint16_t)((float)intervalMs / 0.625f + 0.5f);
    adv->setMinInterval(units);
    adv->setMaxInterval(units);

    NimBLEAdvertisementData emptyResp;
    adv->setScanResponseData(emptyResp);

    adv->setAdvertisementData(advData);
    adv->start();

    _lastAdvUpdate = millis();
  }

  void stopAdvertising() {
    Serial.println("BLE: stopAdvertising()");
    NimBLEAdvertising *adv = NimBLEDevice::getAdvertising();
    adv->stop();
  }

  std::string buildManufacturerData(const char* playerId, uint8_t strengthByte) {
    std::string m;
    m.push_back((char)(MFG_COMPANY_ID & 0xFF));
    m.push_back((char)((MFG_COMPANY_ID >> 8) & 0xFF));
    m.push_back((char)0x01);      // version
    m.push_back((char)0x01);      // occupied=1
    m.push_back((char)strengthByte);

    uint8_t tileLen = strlen(TILE_ID);
    uint8_t playerLen = strlen(playerId);

    m.push_back((char)tileLen);
    for (uint8_t i = 0; i < tileLen; i++) m.push_back(TILE_ID[i]);

    m.push_back((char)playerLen);
    for (uint8_t i = 0; i < playerLen; i++) m.push_back(playerId[i]);

    if (m.size() > 30) {
      m.resize(30);
    }
    return m;
  }

  void updateAdvPacket(float strength) {
    NimBLEAdvertising *adv = NimBLEDevice::getAdvertising();
    if (!adv->isAdvertising()) return;

    float s = strength;
    if (s < 0) s = 0;
    if (s > 2047) s = 2047;
    uint8_t strByte = (uint8_t)(s / 8.0f);

    NimBLEAdvertisementData advData;
    advData.setFlags(0x06);
    advData.setCompleteServices(NimBLEUUID(SHARED_SERVICE_UUID_STR));

    std::string mfg = buildManufacturerData(
        _haveCurrentTag ? _bestTagName.c_str() : "PT-UNK",
        strByte
    );
    advData.setManufacturerData(mfg);
    advData.setName(TILE_ID);

    adv->setAdvertisementData(advData);
  }
};

// global reporter
BleReporter reporter;

// ============================================================================
// ------------------- GLOBAL PRESENCE STATE ----------------------------------
// ============================================================================
bool g_playerPresent = false;
float g_lastDt = 0.0f;

// ============================================================================
// ------------------- Arduino setup / loop -----------------------------------
// ============================================================================
void setup() {
  Serial.begin(115200);
  delay(200);

  statusLed.begin(64);
  statusLed.off();

  initQMC5883P();
  tStart = millis();
  Serial.println("Building 15s EMA baseline...");

  //reporter.begin();
}

void loop() {
  int16_t rx, ry, rz;
  //if (!readQMC5883PData(rx, ry, rz)) {
  //  delay(10);
  //  return;
 // }

  float x = rx;
  float y = ry;
  float z = rz;

  unsigned long now = millis();

  // ================= BASELINE PHASE =================
  if (!baselineDone) {
    if (!baselineInit) {
      baseX = x; baseY = y; baseZ = z;
      baselineInit = true;
    } else {
      baseX = BASELINE_ALPHA * x + (1 - BASELINE_ALPHA) * baseX;
      baseY = BASELINE_ALPHA * y + (1 - BASELINE_ALPHA) * baseY;
      baseZ = BASELINE_ALPHA * z + (1 - BASELINE_ALPHA) * baseZ;
    }

    Serial.println(F(">baseline_building:1"));
    statusLed.off();

    if (now - tStart >= BASELINE_MS) {
      baselineDone = true;
      Serial.println(F("=== Baseline established ==="));
      Serial.print(F("base_x: ")); Serial.println(baseX, 2);
      Serial.print(F("base_y: ")); Serial.println(baseY, 2);
      Serial.print(F("base_z: ")); Serial.println(baseZ, 2);
      Serial.println(F("==========================="));
    }
    delay(10);
    return;
  }

  // ================= RUN PHASE =================
  float dx = x - baseX;
  float dy = y - baseY;
  float dz = z - baseZ;
  float dt = magnitude3D(dx, dy, dz);
  float rawMag = magnitude3D(x, y, z);

  if (!outputEmaInit) {
    fDx = dx;
    fDy = dy;
    fDz = dz;
    fDt = dt;
    outputEmaInit = true;
  } else {
    fDx = OUTPUT_ALPHA * dx + (1 - OUTPUT_ALPHA) * fDx;
    fDy = OUTPUT_ALPHA * dy + (1 - OUTPUT_ALPHA) * fDy;
    fDz = OUTPUT_ALPHA * dz + (1 - OUTPUT_ALPHA) * fDz;
    fDt = OUTPUT_ALPHA * dt + (1 - OUTPUT_ALPHA) * fDt;
  }

  g_lastDt = fDt;

  // Teleplot / debug
  Serial.print(F(">DX:")); Serial.println(fDx, 2);
  Serial.print(F(">DY:")); Serial.println(fDy, 2);
  Serial.print(F(">DZ:")); Serial.println(fDz, 2);
  Serial.print(F(">DT:")); Serial.println(fDt, 3);
  Serial.print(F(">RAW_MAG:")); Serial.println(rawMag, 3);
  Serial.println(F(">baseline_building:0"));

  // presence FSM
  if (!g_playerPresent) {
    if (fDt >= MIN_ON_DT) {
      g_playerPresent = true;
    }
  } else {
    if (fDt <= OFF_HYST_DT) {
      g_playerPresent = false;
    }
  }

  // LED state
  if (!g_playerPresent) {
    statusLed.red();
  } else {
    if (fDt >= STRONG_DT) {
      statusLed.green();
    } else {
      statusLed.yellow();
    }
  }

  // BLE reporter
  //reporter.update(g_playerPresent, fDt);

  delay(10);   // ~100 Hz
}
